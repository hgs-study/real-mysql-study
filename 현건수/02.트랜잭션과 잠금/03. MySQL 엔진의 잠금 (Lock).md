## MySQL 엔진의 잠금 (Lock)

- 글로벌 락
- 테이블 락
- 네임드 락
- 메타데이터 락

### 글로벌 락

- 글로벌 락은 `FLUSH_TABLES_WITH_READ_LOCK`  명령으로 획득할 수 있으며, MySQL에서 제공하는 잠금 가운데 가장 범위가 크다.
- 일단 한 세션에서 글로벌 락을 획득한다면 다른 세션에서 **SELECT를 제외한 대부분의 DDL문장이나 DML 문장을 실행하는 경우 글로벌 락이 해제될 때까지 해당 문장이 대기 상태**로 남는다.
- MySQL 서버 전체에 영향을 미치며, 작업 대상 테이블이나 데이터베이스가 다르더라도 동일하게 영향을 미친다.
- 여러 데이터 베이스에 존재하는 MyISAM이나 MEMORY 테이블에 대해 mysqldump로 일관된 백업을 받아야할 때 사용해야한다.

#### 주의

- 글로벌 락이 실행되기 전에 테이블이나 레코드에 쓰기 잠금을 거는 SQL이 실행됐다면 이 명령은 해당 테이블의 읽기 잠금을 걸기 위해 `먼저 실행된 SQL과 그 트랜잭션이 완료될 때까지 기다려야한다.`
- 글로벌 락은 MySQL 서버의 모든 테이블에 큰 영향을 미치기 때문에 웹 서비스용으로 사용되는 MySQL 서버에서는 **가급적 사용하지 않는 것**이 좋다.

### 테이블 락

- 개별 테이블 단위로 설정되는 잠금이며, 명시적 또는 묵시적으로 락을 획득할 수 있다.
- 명시적 락은 `LOCK TABLES table_name [READ|WRITE]` 명령으로 락 획득 가능
- 묵시적 락은 MyISAM이나 MEMORY 테이블에 데이터를 변경하는 쿼리를 실행하면 발생
    - MySQL 서버 데이터가 변경되는 테이블에 잠금을 하고 데이터 변경 후 즉시 잠금 해제
    - InnoDB는 레코드 기반이라 묵시적 테이블락 X
    - 더 정확히는, InnoDB 테이블에도 테이블 락이 설정되지만 대부분의 데이터 변경(DML) 쿼리에서는 무시되고 `스키마를 변경하는 쿼리(DDL)의 경우`만 영향을 미친다.

#### 주의

- 명시적인 테이블 락도 특별한 상황에 거의 사용할 필요가 없다. 온라인 작업에 상당한 영향

### 네임드 락

- 네임드 락은 `GET_LOCK()` 을 이용해서 임의의 `문자열에 대해 잠금`을 설정
- 대상이 테이블이나 레코드 또는 AUTO_INCREMENT와 같은 데이터 베이스 객체가 아니라, 단순히 `사용자가 지정한 문자열(String)에 대해 획득하고 반납`
- 예를 들어, 데이터베이스 서버 1대에 5대의 웹 서버가 접속해서 서비스하는 상황에서는 5대의 웹 서버가 어떤 정보를 동기화해야하는 요건처럼 `여러 클라이언트가 상호 동기화 처리`해야할 때 네임드 락을 이용하면 쉽게 해결할 수 있다. `(=분산락)`

```jsx
SELECT GET_LOCK('myLock',2);
// "myLock"이라는 문자열에 대해 잠금을 획득한다.
// 이미 잠금을 사용 중이면 2초 동안만 대기한다. (2초 이후 자동 잠금 해제)

SELECT IS_FREE_LOCK("myLock");
// "myLock" 잠금을 확인한다.

SELECT RELEASE_LOCK("myLock");
// "myLock"이라는 문자열에 대해 획득했던 잠금 반납

SELECT RELEASE_ALL_LOCKS();
// 8.0버전부터는 락을 중첩해서 사용 가능하며, 현재 세션에서 획득한 네임드 락을 한번에 모두 해제 가능

// 3개 함수 모두 획득하거나 해제할 경우 1, 아니거나 Null이면 0 반환
```

#### 주의

- 배치 프로그램에서 한꺼번에 많은 레코드를 변경하는 쿼리는 자주 데드락의 원인이 된다.
- 동일 데이터를 변경하거나 참조하는 프로그램끼리 `분류해서 네임드 락을 걸고 쿼리를 실행하면 간단히 해결`할 수 있다.

### 메타데이터 락

- 메타데이터 락은 데이터베이스 객체(대표적으로 테이블이나 뷰 등)의 이름이나 구조를 변경하는 경우에 획득하는 잠금
- 명시적으로 획득할 수 없고, `RENAME TABLE tab_a TO tab_b` 와 같이 테이블의 이름을 변경하는 경우 `자동`으로 획득하는 잠금
