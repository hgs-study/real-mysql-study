## InnoDB 스토리지 엔진의 잠금 (Lock)

![image](https://user-images.githubusercontent.com/76584547/168465305-09109944-144b-45dd-b042-d8dd682f1e9b.png)

- 레코드 락
- 갭 락
- 넥스트 키 락
- 자동 증가 락

### 레코드 락

- 레코드 자체만을 잠그는 것을 레코드락이라고 하며, 다른 사용 DBMS의 레코드 락과 동일한 역할
- 중요한 차이는 InnoDB 스토리지 엔진은 레코드 자체가 아니라 `인덱스의 레코드` 를 잠근다는 점이다.
- 인덱스가 하나도 없는 테이블이더라도 내부적으로 자동생성된 `클러스터 인덱스` 를 이용해서 잠금을 설정한다.
- 프라이머리 키 또는 유니크 인덱스는 갭락을 걸지 않고 `레코드 자체`에 대해서만 락을 건다.

### 갭 락

- 다른 DBMS와의 또 다른 차이가 바로 갭락이다.
- 갭락은 레코드 자체가 아니라 `레코드와 바로 인접한 레코드의 사이 간격`만 잠근다
- 갭락의 역할은 `레코드와 레코드 사이의 간격에 새로운 레코드가 생성(INSERT)`되는 것을 **제어**

### 넥스트 키 락

- 레코드 락과 갭 락을 합쳐 놓은 형태
- STATEMENT 포맷의 바이너리 로그를 사용하는 MySQL 서버는 REPEATABLE READ 격리 수준을 사용해야한다
- InnoDB의 갭 락이나 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주목적
- 넥스트 키락으로 데드락이나 트랜잭션이 기다리는 일이 많기 때문에 , 가능하다면 바이너리 로그 포맷을 ROW 형태로 바꿔서 넥스트 키락이나 갭락을 줄이는 것이 좋다

```
CODE가 2에서 넥스트 키 락이 걸리면 1~2사이에 갭락, 2~3 사이의 갭락이 잡히면서 1 ~ 3 사이에
새로운 레코드를 생성(INSERT) 못하는 것을 말한다.

CODE
---
1
2
3
```

### 자동 증가 락

- MySQL 5.O
    - AUTO_INCREMENT를 제공할 때 내부적으로 락을 건다.
    - AUTO_INCREMENT 락은 트랜잭션과 관계 없이 INSERT나 REPLACE 문장에서 AUTO_INCREMENT 값을 가져오는 순간만 락을 걸렸다가 즉시 해제한다.
    - 해당 락은 테이블에 하나만 존재하기 때문에 두개의 INSERT 쿼리가 동시에 실행되는 경우, 후행 쿼리는 락을 기다려야한다.

```
innodb_autoinc_lock_mode = 0
// Insert 문장은 자동 증가 락을 사용한다.
```

- MySQL 5.7
    - 단순히 한 건 또는 여러 건의 레코드의 건수를 정확히 예측할 경우 자동 증가 락을 사용하지 않고, 훨씬 가볍고 빠른 `래치(뮤텍스)` 를 이용해 처리한다.
    - 래치는 자동 증가 락과 달리 아주 짧은 시간 동안만 잠금을 걸고 필요한 자동 증가 값을 가져오면 락이 해제된다.

```
innodb_autoinc_lock_mode = 1
```

- MySQL 8.0
    - 절대 자동 증가 락을 걸지 않고 경량화된 래치(뮤텍스)를 사용
    - 이 설정에서는 하나의 INSERT 문장으로 INSERT되는 레코드라고 하더라도 `연속된 자동 증가 값을 보장하지 않는다.` (= 인터리빙 모드)
    - 동시처리 높음
    - 이 설정에서 자동 증가 기능은 유니크한 값이 생성된다는 것만 보장

```
innodb_autoinc_lock_mode = 2
```

- AUTO_INCREMENT 자동 증가 값이 증가하면 절대 줄어들지 않는 이유가 AUTO_INCREMENT 락을 최소화 하기 위해
    
    

#### 주의

- MySQL 8.0부터는 바이너리 로그 포맷이 STATEMENT가 아니라 ROW 포맷이 기본값이 됐기 때문에 innodb_autoinc_lock_mode = 2 사용 가능
