## 질문 정리

### **1주차 - Mysql 아키텍처**

- 포그라운드 쓰레드와 백그라운드 쓰레드 차이는 무엇인가?
    - 포그라운드 스레드
        - 클라이언트 스레드
        - 최소한 접속된 클라이언트 수만큼 존재
        - 클라이언트가 작업을 마치면 해당 커넥션을 담당하던 스레드는 스레드 캐시로 되돌아간다
        - 데이터를 데이터 버퍼나 캐시로부터 가져오며, 버퍼나 캐시에 없는 경우에는 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어와서 작업 처리
    - 백그라운드 스레드
        - 인서트 버퍼를 병합하는 스레드
        - 로그를 디스크로 기록하는 스레드 (중요 - 쓰기 스레드)
        - InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드 (중요 - 쓰기 스레드)
        - 데이터를 버퍼로 읽어오는 스레드
        - 잠금이나 데드락을 모니터링 하는 스레드
- MySQL 성능 상의 이유로 읽기 작업과 쓰기 작업의 처리 방식이 다른데, 이 부분에 대해서 알고 있는가?
    - 쓰기 작업 - 지연(버퍼링) 후 일괄 처리 가능
    - 읽기 작업 - 지연 작업 X
- DB는 ACID를 유지해야하는데 DML(INSERT, DELETE, UPDATE) 작업 시 버퍼풀로 올릴 경우, 서버가 장애날 경우 어떤 식으로 데이터를 보장하는가?
    - 
- DML(INSERT, DELETE, UPDATE) 작업 시 리두로그와 언두로그의 데이터 변경을 설명해보시오
    - 리두로그
        - UPDATE 시 InnoDB 버퍼풀에 있는 데이터는 업데이트 ⇒ 쓰기 지연 , 일괄 쓰기
        - 버퍼풀에만 UPDATE하고 디스크에는 적재가 안 된 상황에서 장애 발생시
            - 디스크에 있는 리두로그로 복구한다
    - 언두로그
        - UPDATE 시 커밋 실행 여부과 관계 없어 InnoDB 버퍼풀에 있는 데이터를 UPDATE한다.
        - 커밋되기 전 다른 트랜잭션이 해당 데이터를 조회할 경우 메모리의 언두로그에 있는 이전 데이터를 보여준다.
        - 커밋한다고 언두로그의 데이터가 항상 바로 삭제되는 것은 아니다. 이 언두로그를 필요로 하는 트랜잭션이 더는 없을 때 비로소 삭제된다.
- 쿼리 실행 구조를 설명해주세요
    1. 쿼리 파서 (MySQL 엔진)
        - 사용자 요청으로 들어온 쿼리 문장을 토큰(MySQL이 인식할 수 있는 최소 단위의 어휘나 기호)으로 분리해 트리 형태 구조로 만드는 작업
        - 쿼리 문장의 기본 문법 오류는 이 과정에서 발견되고 오류 메세지를 사용자에게 전달
    2. 전처리기 (MySQL 엔진)
        - 파서 과정에서 만들어진 파서 트리를 기반으로 쿼리 문장의 구조적인 문제점 확인
        - 테이블 이름이나, 칼럼 이름, 또는 내장 함수와 같은 개체를 매핑해서 객체의 존재 여부와 객체의 접근권한을 확인하는 과정 수행
    3. 옵티마이저 (MySQL 엔진)
        - 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지를 결정하는 역할 담당
    4. 실행 엔진
        - 실행 엔진은 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할
    5. 핸들러 (스토리지 엔진)
        - MySQL 엔진의 요청에 따라 데이터를 디스크로 저장하고 디스크로부터 읽어오는 역할

### **2주차 - 트랜잭션과 잠금**

- 갭락
    - 레코드 사이 간격 잠금
    - 새로운 데이터가 생성(insert)되는 것을 제어
    - [https://idea-sketch.tistory.com/46](https://idea-sketch.tistory.com/46)
- InnoDB의 레코드 락 방식을 설명해주시오
    - 인덱스가 하나도 없을 경우 동작 방식
- 테이블락이 InnoDB에 영향을 주지 않는데, 특정 상황엔 테이블락이 걸린다. 이 특정 상황은?
    - 스키마를 변경하는 쿼리(DDL)에는 영향을 받는다
- 만약에 DB 서버 1대고 , APP 서버 5대 → DB 동기화시켜야한다 . 이 동기화 방법은?
    - Named Lock 활용
        - 분산 환경에서 사용
        - 잠금 획득
        
        ```sql
        SELECT GET_LOCK('myLock',2) // myLock이라는 문자열에 대해 2초동안 락 획득
        ```
        
        - 배치처럼 한꺼번에 많은 레코드를 변경하는 쿼리는 자주 `데드락`이 발생하는데, 이러한 경우 **동일 데이터를 변경하거나 참조하는 프로그램끼리 분류해서 네임드 락을 걸고 쿼리를 실행하면 아주 간단히 해결할 수 있다.**
- (+ 개인적인 추가 2022.07.26) 데드락 해결법
    - MySQL InnoDB 스토리지 엔진이 제공하는 백그라운드 스레드인 데드락 감지 스레드를 기본적으로 이용할 것 같습니다. 예를 들어, 2개의 트랜잭션이 데드락에 빠졌을 경우, 데드락 감지 스레드는 MySQL 서버가 더 적게 가기 위해 언두로그 양이 더 적은 트랜잭션을 롤백시킨다.
    - 네임드 락 활용. 예를 들어 분산 서버를 활용할 경우, 네임드 락을 활용해서 데드락 유추 지점에 네임드락을 걸고 데드락을 피할 것 같습니다

### **3주차 - 인덱스**

- 테이블 풀스캔과 인덱스 레인지 스캔의 I/O방식 특징
    - 순차 I/O vs 랜덤 I/O
        - 3개의 페이지를 디스크에 기록하기 위해 1번 시스템 콜을 했지만 랜덤 IO는 3번의 시스템 콜을 했다.
        - 디스크의 성능은 디스크 헤ㅐ더 위치 이동없이 얼마나 많은 데이터를 한 번에 기록하느냐에 결정
        - 여러번 쓰기 또는 읽기를 요청하는 랜덤 IO가 훨씬 부하가 크기 때문에 DB는 대부분의 작업은 이러한 작은 데이터를 빈번히 읽고 쓰기 때문에 InnoDB 로그 버퍼 등이 기능이 내장돼있다
- InnoDB 스토리지 엔진이 클러스터링 키를 가지는 조건
    - 프라이머리 키 → 클러스터링 키
    - 유니크 키 → 제일 첫번째 키가 클러스터링 키
    - x → 레코드마다 내부적으로 일련번호 클러스터링 키
- 클러스터링 인덱스 구조가 B-TREE인데, 다른점
    - 클러스터링 - 데이터 레코드를 가지고 있다
- InnoDB와 MyISAM의 세컨더리 인덱스로 검색할 때의 차이점
    - MyISAM은 인덱스를 검색해 레코드의 주소를 확인하고, 레코드의 주소로 최종 레코드를 가져옴
    - InnoDB : 인덱스를 검색해 레코드의 프라이머리 키 값을 확인하고, 프라이머리 키 인덱스를 검색해서 최종 레코드를 가져옴
- 유니크 인덱스 vs 세컨 인덱스
    - 유니크, 세컨더리 인덱스 중에 유니크 더 빠르다(?)
    - 인덱스 읽기
        - 읽는 레코드 수만 같다면 성능상 차이는 미미하다
    - 인덱스 쓰기
        - 인덱스 키 - 버퍼링 가능 vs 유니크 - 중복체크 때문에 버퍼링 불가능
        - 유니크 : 무조건 중복체크 ⇒ 더 느리다
        - 유니크 인덱스 중복 체크시 읽기랑 쓰기 잠금이 데드락 빈번

### **4주차 - 옵티마이저와 힌트**

- 쿼리 실행 순서에 대해 설명해주세요
    1. 쿼리 파서 (MySQL 엔진)
        - 사용자 요청으로 들어온 쿼리 문장을 토큰(MySQL이 인식할 수 있는 최소 단위의 어휘나 기호)으로 분리해 트리 형태 구조로 만드는 작업
        - 쿼리 문장의 기본 문법 오류는 이 과정에서 발견되고 오류 메세지를 사용자에게 전달
    2. 전처리기 (MySQL 엔진)
        - 파서 과정에서 만들어진 파서 트리를 기반으로 쿼리 문장의 구조적인 문제점 확인
        - 테이블 이름이나, 칼럼 이름, 또는 내장 함수와 같은 개체를 매핑해서 객체의 존재 여부와 객체의 접근권한을 확인하는 과정 수행
    3. 옵티마이저 (MySQL 엔진)
        - 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지를 결정하는 역할 담당
    4. 실행 엔진
        - 실행 엔진은 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할
    5. 핸들러 (스토리지 엔진)
        - MySQL 엔진의 요청에 따라 데이터를 디스크로 저장하고 디스크로부터 읽어오는 역할
- InnoDB 엔진으로 테이블 풀스캔 할 때, 빠른 처리를 위해 리드 어헤드를 사용하는데, 리드 어헤드를 설명해주세요
    - 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측해서 요청이 오기 전에 미리 디스크에서 읽어서 InnoDB의 버퍼풀에 가져다 두는 것을 의미
    - 테이블 풀스캔이 실행되면 처음 몇 개의 데이터 페이지는 포그라운드 스레드가 페이지 읽기를 실행하지만 특정 시점부터는 읽기 작업을 `백그라운드 스레드로 넘긴다`. 백그라운드 스레드가 읽기를 넘겨 받는 시점부터 한 번에 4개 또는 8개 씩 페이지를 읽으면서 계속 그 수를 증가시킨다. 최대 64개 페이지까지 읽어서 `버퍼 풀`에 저장 ⇒ **포그라운드 스레드는 미리 버퍼풀에 준비된 데이터를 가져다 사용하기만 하면 되므로 쿼리가 상당히 빨리 처리 되는 것**
- 정렬 시, 소트버퍼와 디스크에 저장하면서 사용하는데, 이를 `멀티 머지` 라고 하는데 간단하게 설명해주세요.
    - 소트 버퍼 : MySQL은 정렬을 수행하기 위해 별도의 메모리 공간을 할당 받아서 사용, 이 메모리 공간을 소트 버퍼라고 한다.
    - 멀티 머지 : 메모리의 소트 버퍼에서 정렬을 수행하고, 그 결과를 임시로 디스크에 기록해둔다. 그리고 다음 레코드를 가져와서 다시 정렬해서 반복적으로 디스크에 임시 저장한다. 이처럼 `각 버퍼 크기만큼 정렬된 레코드를 다시 병합하면서 정렬 수행`
