## InnoDB 버퍼 풀
<p align="center">
  <img src="https://user-images.githubusercontent.com/76584547/166460236-c18fbaf6-8f03-44a1-8a9e-6260ebc2c604.png">
</p>

- InnoDB 스토리지 엔진에서 가장 핵심적인 부분으로, `디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시`해 두는 공간
- `쓰기 작업을 지연`시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할
- 일반적인 애플리케이션에서는 INSERT, UPDATE, DELETE 처럼 데이터를 변경하는 쿼리는 데이터 파일의 이곳저곳에 위치한 레코드를 변경하기 때문에 `랜덤한 디스크 작업을 발생`
- 하지만 버퍼 풀이 이러한 변경된 `데이터를 모아서 처리하면 랜덤한 디스크 작업 횟수를 줄인다`

### 크기 설정

- MySQL 서버 내에서 메모리를 필요로 하는 부분은 크게 없지만 아주 독특한 경우 레코드 버퍼가 상당한 메모리를 사용하기도 한다.
- `레코드 버퍼` 란?
    - 각 클라이언트 `세션에서 테이블의 레코드를 읽고 쓸 때 버퍼`로 사용하는 공간
    - 커넥션이 많고 사용하는 테이블도 많다면 레코드 버퍼 용도로 사용되는 메모리 공간이 꽤 많이 필요해질 수도 있다.
    - MySQL 서버가 사용하는 `레코드 버퍼 공간은 별도로 설정할 수 없다.`
    - 전체 `커넥션 개수와 커넥션에서 읽고 쓰는 테이블 개수`에 따라 결정된다.
- 권장
    - MySQL 5.7버전부터는 동적으로 조절 가능, 작은 값으로 설정 후 유동적으로 증가
    - 운영체제의 전체 메모리 공간이 8GB 미만이라면 50% 정도만 InnoDB 버퍼풀로 설정하고 나머지 메모리 공간은 MySQL 서버와 운영체제, 그리고 다른 프로그램이 사용하는 공간으로 확보
    - 버퍼 풀을 줄이는 작업은 서비스 영향도가 매우 크므로 `줄이는 작업은 삼가`

### 버퍼풀의 페이지 크기 조각을 관리하기 위한 3가지 자료구조
> InnoDB 버퍼 풀은 거대한 메모리 공간을 `페이지 크기의 조각으로 쪼개어 데이터 저장`
- LRU 리스트
- 플러시 리스트
- 프리 리스트

### LRU(Least Recently Used) 리스트
<p align="center">
  <img src="https://user-images.githubusercontent.com/76584547/166460065-c43057aa-e01f-4b07-85cc-dd0596a150b7.png">
</p>

> LRU와 MRU(Most Recently Used) 리스트가 결합된 형태
- Old 서브리스트 : LRU
- New 서브리스트 : MRU
- 디스크로부터 한 번 읽어온 페이지를 최대한 오랫동안 InnoDB 버퍼풀의 메모리에 유지해서 디스크 읽기를 최소화 하는 것

### 플러시(Flush) 리스트
> 디스크로 동기화되지 않은 데이터를 가진 데이터 페이지`(= 더티 페이지)의 변경 시점 기준의 페이지 목록을 관리`
+ 디스크에서 읽은 상태 그대로 전혀 `변경이 없다면 플러시 리스트에 관리되지 않는다.`
+ 하지만 한 번이라도 `데이터 변경이 가해진 데이터 페이지는 플러시 리스트에 관리`되고, 특정 시점에 디스크로 기록돼야 한다.
+ 데이터가 변경되면, `변경 내용을 리두 로그에 기록`하고 버퍼 풀의 데이터 페이지에도 변경 내용을 반영한다.
+ 그래서 **리두 로그의 각 엔트리는 특정 데이터 페이지와 연결된다.**
> InnoDB는 체크포인트를 발생시켜 디스크의 리두로그와 데이터 페이지의 상태를 동기화한다.
> `체크포인트`란? MySQL 서버가 시작될 때 InnoDB 리두 로그의 어느 부분부터 복구를 실행해야할지 판단하는 기준점을 만드는 역할

### 프리(Free) 리스트
- InnoDB 버퍼 풀에서 실제 사용자 데이터로 채워지지 않은 `비어 있는 페이지들의 목록`
- 사용자의 쿼리가 새롭게 디스크의 데이터 페이지를 읽어올 때 사용

### InnoDB 스토리지 엔진에서 데이터를 찾는 과정
1. 필요한 레코드 저장된 데이터 페이지가 `버퍼 풀에 있는지 검사`
    1. InnoDB 어댑티브 해시 인덱스를 통해 페이지 검색
    2. 해당 테이블의 인덱스(B-Tree)를 이용해 버퍼 풀에서 페이지를 검색
    3. 버퍼풀에 이미 데이터 페이지가 있었다면 해당 페이지의 포인터를 MRU 방향으로 승급
2. 디스크에서 필요한 데이터 페이지를 `버퍼 풀에 적재`하고, 적재된 페이지에 대한 포인터를 LRU 헤더 부분에 추가
3. 버퍼 풀의 LRU 헤더 부분에 적재된 데이터 페이지가 `실제로 읽히면 MRU 헤더 부분으로 이동` (Read Ahead와 같이 대량 읽기의 경우, 디스크의 데이터 페이지가 버퍼 풀로 적재는 되지만 실제 쿼리에서 사용되지는 않을 수도 있으며, 이런 경우에는 MRU에로 이동하지 않음)
4. 버퍼 풀에 상주하는 데이터 페이지는 사용자 쿼리가 얼마나 최근에 접근했었는지에 따라 나이(Age)가 부여되며, 버퍼 풀에 상주하는 동안 쿼리에서 오랫동안 사용되지 않으면 데이터 페이지에 부여된 나이가 오래되고 (Aging) 결국 해당 페이지는 버퍼 풀에서 제거된다. `버퍼 풀의 데이터 페이지가 쿼리에 의해 사용되면 나이가 초기화 되어 다시 젊어지고 MRU 헤더 부분으로 옮겨진다.`
5. 필요한 데이터가 `자주 접근됐다면 해당 페이지의 인덱스 키를 어댑티브 해시 인덱스`에 추가
    
#### 어댑티브 해시 인덱스
> `자주 사용되는 칼럼을 해시로 정의하여, B-Tree 를 타지 않고 바로 데이터에 접근`할 수 있는 기능


