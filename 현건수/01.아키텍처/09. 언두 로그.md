## 언두 로그

> 트랜잭션과 격리 수준으 ㄹ보장하기 위해  DML(INSERT, DELETE, UPDATE)로 변경되기 이전 버전의 데이터를 별도로 백업한다. 이렇게 백업된 데이터를 `언두 로그` 라고 한다.
> 

### 트랜잭션 보장

- 트랜잭션이 롤백되면 트랜잭션 도중 변경된 데이터를 `변경 전 데이터로 복구`해야 하는데, 이때 `언두 로그에 백업해둔 이전 버전의 데이터`를 이용해 복구한다.

### 격리 수준 보장

- 특정 커넥션에서 `데이터를 변경하는 도중 다른 커넥션에서 데이터를 조회`하면, 트랜잭션 격리 수준에 맞게 변경 중인 레코드를 읽지 않고 `언두 로그에 백업해둔 데이터`를 읽어서 반환

### 언두 로그 트랜잭션

```sql
update member set name = '홍길동' where member_id = 1;
```

- `트랜잭션을 커밋하지 않아도` **실제 데이터(데이터/인덱스 버퍼) 내용은 ‘홍길동’으로 변경**
- 변경되기 전 값이 ‘벽계수’였다면, 언두 영역에는 `벽계수`라는 값이 백업
- 이 상태에서 사용자가 `커밋`하면 현재 상태 유지
- 이 상태에서 사용자가 `롤백`하면 `언두 영역의 백업된 데이터`(’벽계수’)를 다시 데이터 파일로 복구

### 언두 로그 용도

- 트랜잭션 롤백용
- 트랜잭션 격리 수준을 유지하면서 높은 동시성 제공

### 언두 로그 트랜잭션 예시

<p align="center">
  <img src="https://user-images.githubusercontent.com/76584547/166477625-9b6d91f8-a908-4acf-9444-0d9c09b5a05b.png">
</p>

- B,C 트랜잭션은 완료 됐지만 A트랜잭션은 아직 미완료
- B,C 트랜잭션은 UPDATE, DELETE를 실행했으므로 변경 이전의 언두로그를 백업
- 하지만 먼저 실행된 A 트랜잭션이 아직 활성 상태이기 때문에 B,C 트랜잭션의 완료 여부와 관계 없이 B,C 트랜잭션이 만들어낸 언두로그는 삭제되지 않는다.

### 언두 로그 유의 사항

- 트랜잭션을 종료하지 않고 하루종일 쿼리가 실행됐다고 가정하면
    - 하루 종일의 언두 로그가 쌓이게 될 것
    

### 언두 로그 조회

```sql
show engine innodb status /g
```
