# MySQL 엔진 아키텍처
+ 사람 머리역할을 담당하는 `MySQL 엔진`과 손발 역할을 담당하는 `스토리지 엔진`으로 구분

<br/>

### MySQL 전체 구조

+ MySQL 엔진
  + 요청된 SQL 문장을 분석하거나 최적화하는 등 DBMS의 두뇌에 해당하는 처리 수행
  + `커넥션 핸들러`와 `SQL 파서` : 클라이언트로부터의 접속 및 쿼리 요청을 처리
  + `옵티마이저` : 쿼리 최적화 실행 계획 수립

+ 스토리지 엔진
  + 실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 부분 전담
<p align="center">
  <img src="https://user-images.githubusercontent.com/76584547/164261876-dc3b73b9-69c2-4fb7-aea8-58dfe742ce14.png">
</p>

>  MySQL 서버에서 MySQL 엔진은 하나지만, 스토리지 엔진은 여러개를 동시에 사용할 수 있다.

<br/>

### 핸들러 API
`핸들러` : MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때는 각 스토리지 엔진에 쓰기 또는 읽기 요청을 하는데 이러한 요청을 `핸들러 요청`이라고 하고, 여기서 사용되는 API를 `핸들러 API`라고 한다.
> mysql > SHOW GLOBAL STATUS LIKE 'Handler%'; // 핸들러 API를 통해 얼마나 많은 데이터(레코드)작업이 있었는지 확인

<br/>

### MySQL 스레딩 구조
+ MySQL 서버는 프로세스 기반이 아니라 스레드 기반으로 작동하며, 크게 `포그라운드 스레드`와 `백그라운드 스레드`로 구분할 수 있다.

<p align="center">
  <img src="https://user-images.githubusercontent.com/76584547/164266896-0264202d-d53d-4d86-bfb4-43a63e44eb43.png">
</p>

### 포그라운드 스레드 (클라이언트 스레드)
+ 최소한 MySQL 서버에 접속된 클라이언트의 수만큼 존재
+ 주로 각 클라이언트 사용자가 요청하는 쿼리 문장을 처리
+ 클라이언트 사용자가 작업을 마치고 커넥션을 종료하면 해당 커넥션을 담당하던 스레드는 다시 `스레드 캐시`로 되돌아간다.
+ 이미 스레드 캐시에 일정 개수 이상의 대기 중인 스레드가 있으면 스레드 캐시에 넣지 않고 스레드를 종료시켜 일정 개수의 스레드만 스레드 캐시에 존재하게 한다.

#### 역할
+ 데이터를 MySQL의 데이터 버퍼나 캐시로부터 가져오며, 버퍼나 캐시에 없는 경우에는 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어와서 작업을 처리한다.
+ `InnoDB` : 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리, 나머지 버퍼로부터 디스크까지 기록하는 작업은 백그라운드 스레드가 처리
+ `MyISAM` : 디스크 쓰기 작업까지 포그라운드 스레드가 처리 (MyISAM도 지연된 쓰기가 가능)

<br/>

### 백그라운드 스레드
> MyISAM의 경우에는 별로 해당 사항이 없는 부분이지만 InnoDB는 다음과 같이 여러 가지 작업이 백그라운드로 처리
+ 인서트 버퍼를 병합하는 스레드 (중요)
+ 로그를 디스크로 기록하는 스레드 - 쓰기스레드 (중요)
+ InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
+ 데이터를 버퍼로 읽어 오는 스레드
+ 잠금이나 데드락을 모니터링하는 스레드

#### 특징
+ 사용자의 요청을 처리하는 도중 데이터의 쓰기 작업은 지연(버퍼링)되어 처리될 수 있지만 데이터의 읽기 작업은 절대 지연될 수 없다.
+ 하지만 MyISAM은 그렇지 않고 사용자 스레드가 쓰기 작업까지 함께 처리한다.
+ 이러한 이유로 InnoDB는 CUD 쿼리로 데이터가 변경되는 경우 디스크의 데이터 파일로 완전히 저장될 때까지 기다리지 않아도 된다.
+ 하지만 MyISAM에서는 일반적인 쿼리는 쓰기 버퍼링을 사용할 수 없다.
